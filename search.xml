<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Qt—知识点</title>
      <link href="2020/12/27/Qt%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
      <url>2020/12/27/Qt%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Qt—知识点"><a href="#Qt—知识点" class="headerlink" title="Qt—知识点"></a>Qt—知识点</h1><a id="more"></a><h4 id="程序的构建可能会失败问题"><a href="#程序的构建可能会失败问题" class="headerlink" title="程序的构建可能会失败问题"></a>程序的构建可能会失败问题</h4><p><img src="D:\Blog\source\images\1.jpg"><br>每次构建一次项目时,它都会生成一个这样的文件,这个文件的意思是,你本机电脑的构建目录,它与QT里的构建目录挂钩:<br><img src="D:\Blog\source\images\2.jpg"><br>所以当你使用别的程序时,要把这个文件给删掉再构建不然会出错,因为你和他在构建这个程序时目录是不一样的</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt—相关语法</title>
      <link href="2020/12/26/Qt%E2%80%94%E7%9B%B8%E5%85%B3%E8%AF%AD%E6%B3%95/"/>
      <url>2020/12/26/Qt%E2%80%94%E7%9B%B8%E5%85%B3%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="相关语法"><a href="#相关语法" class="headerlink" title="相关语法"></a>相关语法</h1><a id="more"></a><h4 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h4><p>条件:&ensp; <code>QPushButton a;</code><br>用途:&ensp; 获取a的size,可由一个QSize对象获取<br>例子:&ensp; <code>QSize b=a.size();</code><br><strong>注意</strong>:&ensp; b应该是一个二维值,因为size有宽和长</p><h4 id="resize-const-const"><a href="#resize-const-const" class="headerlink" title="resize(const,const)"></a>resize(const,const)</h4><p>条件:&ensp; <code>QPushButton a;</code><br>用途:&ensp; 修改按钮a的size<br>例子:&ensp; <code>a.resize(40,40);</code><br><strong>注意</strong>:</p><h4 id="qDebug的使用"><a href="#qDebug的使用" class="headerlink" title="qDebug的使用"></a>qDebug的使用</h4><p>条件:&ensp; <code>#include &lt;QDebug&gt;</code><br>用途:&ensp; 与C++语法cout一样,用作打印<br>例子:&ensp; <code>qDebug() &lt;&lt;a &lt;&lt;str ;</code><br><strong>注意</strong>:&ensp; 这里是qDebug()而不是QDebug。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt—信号与槽</title>
      <link href="2020/12/26/Qt%E2%80%94%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/"/>
      <url>2020/12/26/Qt%E2%80%94%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a>信号与槽</h1><a id="more"></a><h4 id="connent函数"><a href="#connent函数" class="headerlink" title="connent函数"></a>connent函数</h4><p> <strong>connect函数参数:</strong><br> <strong>1. 信号发出者,指针类型。</strong><br> <strong>2. 处理的信号,&amp;取地址,发送者的类名::信号名。</strong><br> <strong>3. 信号接收者。</strong><br> <strong>4. 槽函数:信号处理函数,函数接收者的类名::信号名。</strong></p><p>例如:</p><pre><code>connect(&amp;a,&amp;QPushButton::pressed,this,&amp;MainWidget::close);/* * &amp;a 信号发出者,指针类型 * &amp;QPushButton::pressed 处理的信号,&amp;取地址,发送者的类名::信号名 * this 信号接收者 * &amp;MainWidget::close 槽函数:信号处理函数,函数接收者的类名::信号名 */</code></pre><p>解释:a是一个按钮,当你pressed这个按钮后,a发出一个信号,给this对象(也就是父对象),然后this接受后,作出close的行为。</p><p>这里的close和pressed皆为标准函数,如何自己自定义一个槽函数呢?<br>首先,我需要在头文件里声明一个函数:</p><pre><code>public:void mySlot();</code></pre><p>然后,我需要在cpp里实现这个函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void MainWidget::mySlot()</span><br><span class="line">&#123;</span><br><span class="line">    b-&gt;setText(&quot;123&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后,在connnect里引用:</p><pre><code>connect(b,&amp;QPushButton::released,this,&amp;MainWidget::mySlot);</code></pre><p><strong>注意:<br>      1. 槽函数需要和信号一致(参数,返回值)<br>      2. 由于信号都是没有返回值的,所以槽函数一定没有返回值</strong></p><p><strong>什么时候需要自定义信号?</strong><br>比如,你老板可以命令你做什么事,但是你不能直接命令老板做事,你需要先私下里发个信息给老板,等待老板确定并执行。这里的这个信息,就是你要自定义的信号。</p><h4 id="如何自定义信号-无参数"><a href="#如何自定义信号-无参数" class="headerlink" title="如何自定义信号(无参数)?"></a>如何自定义信号(无参数)?</h4><p>1.你要在子对象的.h文件里里创建signal声明:</p><pre><code>signals:void mySignal();</code></pre><p>2.接着在.h文件里创建一个送出这个信号的函数:</p><pre><code>public:void sendSlot();</code></pre><p>3.然后在.cpp文件里实现这个函数:</p><pre><code>void SubWidget::sendSlot()&#123;    emit mySignal();&#125;</code></pre><p>4.在.cpp里运用connect函数将这个信号发给父对象:</p><pre><code>  connect(&amp;a,&amp;QPushButton::clicked,this,&amp;SubWidget::sendSlot);</code></pre><p>5.在父对象的.h文件里,创建一个接收到了这个信号后的处理函数:</p><pre><code>public:void dealSub();</code></pre><p>6.在父对象的.cpp文件里,实现这个函数,就是写你要的操作:</p><pre><code>void MainWidget::dealSub()&#123;    this-&gt;show();    w.hide();&#125;</code></pre><p>7.在父对象运用connect函数,接收信号:<br><strong>注意!!!这里的&amp;SubWidget::mySignal,发送的是信号名!!!而不是sendSlot函数,作为接收者,接收的是这个信号</strong></p><pre><code>connect(&amp;w,&amp;SubWidget::mySignal,this ,&amp;MainWidget::dealSub);</code></pre><h4 id="如何自定义信号-有参数"><a href="#如何自定义信号-有参数" class="headerlink" title="如何自定义信号(有参数)?"></a>如何自定义信号(有参数)?</h4><p>大致步骤与无参定义信号差不多,不同处已<strong>加粗标记</strong><br>1.你要在子对象的.h文件里里创建signal声明:</p><pre><code>signals:void mySignal(int,QString);</code></pre><p>2.接着在.h文件里创建一个送出这个信号的函数:</p><pre><code>public:void sendSlot();</code></pre><p>3.然后在.cpp文件里实现这个函数<strong>并填写上你要添加的参数</strong>:</p><pre><code>void SubWidget::sendSlot()&#123;  emit mySignal(250,&quot;我是子窗口&quot;);&#125;</code></pre><p>4.在.cpp里运用connect函数将这个信号发给父对象:</p><pre><code>  connect(&amp;a,&amp;QPushButton::clicked,this,&amp;SubWidget::sendSlot);</code></pre><p>5.在父对象的.h文件里,创建一个接收到了这个信号后的处理函数,<strong>因为信号是有参数的所以你的槽函数也要有参数</strong>:</p><pre><code>public:void dealSub(int,QString);</code></pre><p>6.在父对象的.cpp文件里,实现这个函数,就是写你要的操作:</p><pre><code>void MainWidget::dealSub(int,QString)&#123;    this-&gt;show();    w.hide();    qDebug() &lt;&lt;a &lt;&lt;str ;//打印a和str的值,详细信息请去Qt相关语法&#125;</code></pre><p>7.在父对象运用connect函数,接收信号:<br><strong>注意!!!这里的&amp;SubWidget::mySignal,发送的是信号名!!!而不是sendSlot函数,作为接收者,接收的是这个信号</strong></p><pre><code>connect(&amp;w,&amp;SubWidget::mySignal,this ,&amp;MainWidget::dealSub);</code></pre><h4 id="信号的重构问题"><a href="#信号的重构问题" class="headerlink" title="信号的重构问题"></a>信号的重构问题</h4><p>信号是可以重构的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">void mySignal();</span><br><span class="line">void mySignal(int,QString);</span><br></pre></td></tr></table></figure><p>此时当你在父对象里创建connect函数与子对象发来的函数相连时:</p><pre><code>  connect(&amp;w,&amp;SubWidget::mySignal,this ,&amp;MainWidget::dealSub);</code></pre><p>会发生报错,错误原因:<strong>子对象发送的这个mySignal,父对象不知道你发的是无参的还是有参的。</strong><br>所以你需要用<strong>指针来分别指向有参和无参信号函数</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connect(&amp;c,&amp;QPushButton::pressed,this,&amp;MainWidget::showchild);</span><br><span class="line">void (SubWidget::*funSignal)()&#x3D;&amp;SubWidget::mySignal;  &#x2F;&#x2F;这个指针要加上作用域SubWidget::,因为你这个信号是属于SubWidget::子类的</span><br><span class="line">                                                      &#x2F;&#x2F;C++用指针来指定函数★</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt—小知识</title>
      <link href="2020/12/26/Qt%E2%80%94%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
      <url>2020/12/26/Qt%E2%80%94%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h1><a id="more"></a><h4 id="程序的构建可能会失败问题"><a href="#程序的构建可能会失败问题" class="headerlink" title="程序的构建可能会失败问题"></a>程序的构建可能会失败问题</h4><p><img src="C:\Users\LENOVO\Desktop\blog_image\1.jpg"><br>每次构建一次项目时,它都会生成一个这样的文件,这个文件的意思是,你本机电脑的构建目录,它与QT里的构建目录挂钩:<br><img src="C:\Users\LENOVO\Desktop\blog_image\3.jpg"><br>所以当你使用别的程序时,要把这个文件给删掉再构建不然会出错,因为你和他在构建这个程序时目录是不一样的</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt—(1)</title>
      <link href="2020/12/24/Qt%E2%80%94(1)/"/>
      <url>2020/12/24/Qt%E2%80%94(1)/</url>
      
        <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="(1)"></a>(1)</h1><hr><a id="more"></a><blockquote><p>今天的QT学习:<br>(1)Qt应用程序框架<br>(2)父对象的指定&lt;就是将按钮绑定到窗口上&gt;<br>(3)实现两个独立的窗口<br>(4)<strong>信号与槽</strong></p></blockquote><p><strong>Qt应用程序框架:</strong><br>main.cpp</p><pre><code>#include &quot;mywidget.h&quot;#include &lt;QApplication&gt;  //QApplication应用程序类                         //QT头文件没有.h                        //头文件和类名一样                        //前两个字母是大写int main(int argc, char *argv[])&#123;    //有且只有一个应用程序类的对象    QApplication a(argc, argv);    //MyWidget继承于QWidget, QWidget是一个窗口基类    //所以MyWidget也是窗口类    //w就是一个窗口    MyWidget w;    //窗口创建默认是隐藏的,需要show    w.show();    //a.exec();  让程序一直执行,等待用户操作 or 等待事件的发生    //return 0;    return a.exec();&#125;</code></pre><p>mywidget.h</p><pre><code>#ifndef MYWIDGET_H#define MYWIDGET_H#include &lt;QWidget&gt;class MyWidget : public QWidget&#123;    Q_OBJECT   //信号与槽的时候需要public:    MyWidget(QWidget *parent = nullptr);    ~MyWidget();//析构函数,用来扫尾的,就是释放内存等功能&#125;;#endif // MYWIDGET_H</code></pre><p>mywidget.cpp</p><pre><code>#include &quot;mywidget.h&quot;MyWidget::MyWidget(QWidget *parent)    : QWidget(parent)&#123;&#125;MyWidget::~MyWidget()&#123;&#125;</code></pre><p>就是mywidget对象</p><p><strong>父对象的指定&lt;就是将按钮绑定到窗口上&gt;</strong><br>父对象指定有两种方法:</p><ol><li><p>setParent</p><p>QPushButton b;<br>b.setText(“^_^”);  //给标题设置内容<br>b.setParent(&amp;w);<br>b.move(100,100);  //以像素点为单位</p></li><li><p>通过构造函数传参</p><p> QPushButton c(&amp;w);  //通过构造函数传参<br> c.setText(“abc”);</p></li></ol><p>指定父对象,只需要父对象显示,上面的子对象自动显示,这样就不需要一直用show</p><p><strong>实现两个独立的窗口</strong></p><ol><li>右击你的项目add new file</li><li>添加C++ class</li><li>命名,选择基类(父类)为QWidget,下一步</li><li>修改你要放入的文件</li></ol><p><strong>信号与槽</strong><br>关于信号与槽,移步至《Qt—信号与槽》</p><p><strong>项目03_SigalAndSlot实现的是两个窗口,一个父窗口一个子窗口,一开始子窗口是隐藏的,你按父窗口上的按键可以隐藏父窗口显示子窗口,然后你按子窗口上的按键可以隐藏子窗口,显示父窗口</strong></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构—双向链表</title>
      <link href="2020/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>2020/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><a id="more"></a><p><strong>结构体</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct link</span><br><span class="line">&#123;</span><br><span class="line">     int data;</span><br><span class="line">     struct link *left;</span><br><span class="line">     struct link *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>双向链表的创建</strong>：<br>创建添加一个节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct link *addnode(struct link *head)</span><br><span class="line">&#123;</span><br><span class="line">     struct link *p&#x3D;NULL,*pr&#x3D;head;</span><br><span class="line">     int data;</span><br><span class="line">     p&#x3D;new link();</span><br><span class="line">     if(p&#x3D;&#x3D;NULL)</span><br><span class="line">     &#123;</span><br><span class="line">         cout&lt;&lt;&quot;内存分配失败&quot;&lt;&lt;endl;</span><br><span class="line">         exit(0);</span><br><span class="line">     &#125;</span><br><span class="line">     if(head&#x3D;&#x3D;NULL)</span><br><span class="line">     &#123;</span><br><span class="line">         head&#x3D;p;</span><br><span class="line">         p-&gt;left&#x3D;NULL;</span><br><span class="line">     &#125;</span><br><span class="line">     else</span><br><span class="line">     &#123;</span><br><span class="line">         while(pr-&gt;right!&#x3D;NULL)</span><br><span class="line">         &#123;</span><br><span class="line">             pr&#x3D;pr-&gt;right;</span><br><span class="line">         &#125;</span><br><span class="line">         pr-&gt;right&#x3D;p;</span><br><span class="line">         p-&gt;left&#x3D;pr;          &#x2F;&#x2F;关键</span><br><span class="line">     &#125;</span><br><span class="line">     cout&lt;&lt;&quot;请输入节点数据&quot;&lt;&lt;endl;</span><br><span class="line">     cin&gt;&gt;data;</span><br><span class="line">     p-&gt;data&#x3D;data; </span><br><span class="line">     p-&gt;right&#x3D;NULL;</span><br><span class="line">     return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双向链表的节点删除</strong><br>这里是释放一个节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void deletenode(struct link *head,int data)</span><br><span class="line">&#123;</span><br><span class="line">           struct link *p&#x3D;head;</span><br><span class="line">           struct link *p1&#x3D;NULL;</span><br><span class="line">           while(p-&gt;data!&#x3D;data)</span><br><span class="line">           &#123;</span><br><span class="line">               p1&#x3D;p;</span><br><span class="line">               p&#x3D;p-&gt;right;</span><br><span class="line">           &#125;</span><br><span class="line">           p1-&gt;right&#x3D;p-&gt;right;     &#x2F;&#x2F;关键</span><br><span class="line">           p-&gt;right-&gt;left&#x3D;p1;</span><br><span class="line">           free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>列出所有节点信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void DisplayNode(struct link *head) </span><br><span class="line">&#123;</span><br><span class="line">struct link *p&#x3D;head;</span><br><span class="line">int j&#x3D;1;</span><br><span class="line">while(p!&#x3D;NULL)</span><br><span class="line">&#123;</span><br><span class="line">    if(p-&gt;left&#x3D;&#x3D;NULL)</span><br><span class="line">    &#123;</span><br><span class="line">       cout&lt;&lt;&quot;此节点的左节点为:NULL&quot;&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;&quot;此节点的右节点为:&quot;&lt;&lt;p-&gt;right-&gt;data&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(p-&gt;right&#x3D;&#x3D;NULL)</span><br><span class="line">    &#123;</span><br><span class="line">       cout&lt;&lt;&quot;此节点的左节点为:&quot;&lt;&lt;p-&gt;left-&gt;data&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;&quot;此节点的右节点为:NULL&quot;&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">       cout&lt;&lt;&quot;此节点的左节点为:&quot;&lt;&lt;p-&gt;left-&gt;data&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;&quot;此节点的右节点为:&quot;&lt;&lt;p-&gt;right-&gt;data&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    p&#x3D;p-&gt;right;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在固定的位置插入节点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void insertnode(struct link *head,int data)</span><br><span class="line">&#123;</span><br><span class="line">           struct link *p&#x3D;head;</span><br><span class="line">           struct link *p1&#x3D;NULL;</span><br><span class="line">           struct link *p2&#x3D;NULL;</span><br><span class="line">           p2&#x3D;new link();</span><br><span class="line">           int data2;</span><br><span class="line">           while(p-&gt;data!&#x3D;data)</span><br><span class="line">           &#123;</span><br><span class="line">               p1&#x3D;p;</span><br><span class="line">               p&#x3D;p-&gt;right;</span><br><span class="line">           &#125;</span><br><span class="line">           p1&#x3D;p;</span><br><span class="line">           p&#x3D;p-&gt;right;</span><br><span class="line"></span><br><span class="line">           cout&lt;&lt;&quot;请输入你要插入的节点的数据&quot;&lt;&lt;endl;</span><br><span class="line">           cin&gt;&gt;data2;</span><br><span class="line">           p2-&gt;data&#x3D;data2;</span><br><span class="line">           p2-&gt;left&#x3D;NULL;</span><br><span class="line">           p2-&gt;right&#x3D;NULL;</span><br><span class="line"></span><br><span class="line">           p1-&gt;right&#x3D;p2;     &#x2F;&#x2F;关键</span><br><span class="line">           p2-&gt;right&#x3D;p;</span><br><span class="line">           p-&gt;left&#x3D;p2;</span><br><span class="line">           p2-&gt;left&#x3D;p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MAIN函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char juge;</span><br><span class="line">    int i&#x3D;0;</span><br><span class="line">    struct link *head&#x3D;NULL;</span><br><span class="line">    cout&lt;&lt;&quot;是否需要添加一个节点？(Y&#x2F;N)&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;juge;</span><br><span class="line">    while(juge&#x3D;&#x3D;&#39;Y&#39;)</span><br><span class="line">    &#123;</span><br><span class="line">        head&#x3D;addnode(head);</span><br><span class="line">        cout&lt;&lt;&quot;是否需要再添加一个节点？(Y&#x2F;N)&quot;&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;juge;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;请问你是否要删除节点？(Y&#x2F;N)&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;juge;</span><br><span class="line">    if(juge&#x3D;&#x3D;&#39;Y&#39;)</span><br><span class="line">    &#123;</span><br><span class="line">    cout&lt;&lt;&quot;请输入你要删除的节点数据&quot;&lt;&lt;endl;</span><br><span class="line">    int data;</span><br><span class="line">    cin&gt;&gt;data;</span><br><span class="line">    deletenode(head,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;请问你是否要插入节点？(Y&#x2F;N)&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;juge;</span><br><span class="line">    if(juge&#x3D;&#x3D;&#39;Y&#39;)</span><br><span class="line">    &#123;</span><br><span class="line">    cout&lt;&lt;&quot;请输入你要插入在哪个节点后面&quot;&lt;&lt;endl;</span><br><span class="line">    int data;</span><br><span class="line">    cin&gt;&gt;data;</span><br><span class="line">    insertnode(head,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    displaynode(head);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构—单链表</title>
      <link href="2020/11/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
      <url>2020/11/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><a id="more"></a><p><strong>结构体</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct link</span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct link *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>单链表的创建</strong>：<br>创建添加一个节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct link *AddNode(struct link *head)</span><br><span class="line">&#123;</span><br><span class="line">    struct link *p&#x3D;NULL,*pr&#x3D;head;</span><br><span class="line">int data;</span><br><span class="line">p&#x3D;new link(); </span><br><span class="line">if(p&#x3D;&#x3D;NULL)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;分配内存失败&quot;&lt;&lt;endl;</span><br><span class="line">    exit(0);&#x2F;&#x2F;非正常退出</span><br><span class="line">&#125;</span><br><span class="line">if(head&#x3D;&#x3D;NULL)</span><br><span class="line">&#123;</span><br><span class="line">    head&#x3D;p;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    while(pr-&gt;next!&#x3D;NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        pr&#x3D;pr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pr-&gt;next&#x3D;p;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;请输入节点数据&quot;&lt;&lt;endl;</span><br><span class="line">cin&gt;&gt;data;</span><br><span class="line">p-&gt;data&#x3D;data;</span><br><span class="line">p-&gt;next&#x3D;NULL;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单链表的节点删除</strong><br>这里是将所有节点都释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void DeletMemory(struct link*head)</span><br><span class="line">&#123;</span><br><span class="line">    struct link*p&#x3D;head,*pr&#x3D;NULL;</span><br><span class="line">    while(p!&#x3D;NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        pr&#x3D;p;</span><br><span class="line">        p&#x3D;p-&gt;next;</span><br><span class="line">        free(pr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>列出所有节点信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void DisplayNode(struct link *head) </span><br><span class="line">&#123;</span><br><span class="line">     struct link *p&#x3D;head;</span><br><span class="line">     int j&#x3D;1;</span><br><span class="line">     while(p!&#x3D;NULL)</span><br><span class="line">   &#123;</span><br><span class="line">    cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">    p&#x3D;p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##malloc与new<br>1.使用malloc要加上头文件#include<malloc>，并且malloc是和free一起使用的<br>2.(struct link <em>)这条语句的原因是malloc返回的是一个空的指针，你需要将他强制转换为struct link</em>类型的指针，C++规定void *类型可以强转为任何其他类型的的指针。<br>3.malloc函数的意思是分配一个内存大小至少为size参数所指定的字节数。<br>4.malloc的分配的内存大小需要我们自己计算,new可以自动计算。<br><strong>6.在C++中无疑用new来创建是更好的：P=new link();</strong><br>因为：比如你要在结构体中使用string，会出现内存错误，是因为使用malloc分配一个结构体内存，但是string是一个类。并没有调用string的构造函数，所以string在malloc之后没有正确构造，导致使用时段错误。</p><p>详情请见：</p><h3 id="malloc和new的区别"><a href="#malloc和new的区别" class="headerlink" title="malloc和new的区别"></a><a href="https://www.cnblogs.com/QG-whz/p/5140930.html">malloc和new的区别</a></h3>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Don&#39;t want to regret</title>
      <link href="2020/11/16/Te/"/>
      <url>2020/11/16/Te/</url>
      
        <content type="html"><![CDATA[<p>没有执行力，就没有竞争力</p><p>你看我越是穷途末路 越是势如破竹</p><p>城市慷慨亮整夜光，如同少年不惧岁月长</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
