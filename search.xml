<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>考研</title>
      <link href="2021/01/08/%E8%80%83%E7%A0%94/"/>
      <url>2021/01/08/%E8%80%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="考研"><a href="#考研" class="headerlink" title="考研"></a>考研</h1><a id="more"></a><h4 id="数一"><a href="#数一" class="headerlink" title="数一:"></a>数一:</h4><p>高等数学 60%<br>线性代数 20%<br>概率论与数理统计 20%<br>试卷题型结构为:<br>单选题 10小题,每题5分,共50分<br>填空题 6小题,每题5分,共30分<br>解答题(包括证明题) 6小题,共70分</p><h4 id="英一"><a href="#英一" class="headerlink" title="英一:"></a>英一:</h4><p>考试形式<br>考试形式为笔试。考试时间为180分钟。满分为100分。<br>试卷包括试题册和答题卡。答题卡分为答题卡1和答题卡2。考生应将1<del>45题的答案按要求填涂在答题卡1上,将46</del>52题的答案写在答题卡2上。<br>试卷结构<br>试题分三部分,共52题,包括英语知识运用、阅读理解和写作。</p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英一—考研大纲</title>
      <link href="2021/01/08/%E8%8B%B1%E4%B8%80%E2%80%94%E8%80%83%E7%A0%94%E5%A4%A7%E7%BA%B2/"/>
      <url>2021/01/08/%E8%8B%B1%E4%B8%80%E2%80%94%E8%80%83%E7%A0%94%E5%A4%A7%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="英一—考研大纲"><a href="#英一—考研大纲" class="headerlink" title="英一—考研大纲"></a>英一—考研大纲</h1><a id="more"></a><h4 id="第一部分-英语知识运用"><a href="#第一部分-英语知识运用" class="headerlink" title="第一部分 英语知识运用"></a>第一部分 英语知识运用</h4><p>该部分不仅考查考生对不同语境中规范的语言要素(包括词汇、表达方式和结构)的掌握程度,而且还考查考生对语段特征(如连贯性和一致性等)的辨识能力等。共20小题,每小题0.5分,共10分。<br>在一篇240~280词的文章中留出20个空白,要求考生从每题给出的4个选项中选出最佳答案,使补全后的文章意思通顺、前后连贯、结构完整。考生在答题卡1上作答。</p><h4 id="第二部分-阅读理解"><a href="#第二部分-阅读理解" class="headerlink" title="第二部分 阅读理解"></a>第二部分 阅读理解</h4><p>该部分由A、B、C三节组成,考查考生理解书面英语的能力。共30小题,每小题2分,共60分。<br>A节(20小题):主要考查考生理解主旨要义、具体信息、概念性含义,进行有关的判断、推理和引申,根据上下文推测生词的词义等能力。要求考生根据所提供的4篇(总长度约为1 600词)文章的内容,从每题所给出的4个选项中选出最佳答案。考生在答题卡1上作答。<br>B节(5小题):主要考查考生对诸如连贯性、一致性等语段特征以及文章结构的理解。本部分有3种备选题型。每次考试从这3种备选题型中选择一种进行考查。考生在答题卡1上作答。<br>备选题型有:<br>1)本部分的内容是一篇总长度为500到600词的文章,其中有5段空白,文章后有6到7段文字。要求考生根据文章内容从这6~7段文字中选择能分别放进文章中5个空白处的5段。<br>2)在一篇长度约500到600词的文章中,各段落的原有顺序已被打乱。要求考生根据文章的内容和结构将所列段落(7到8个)重新排序,其中有2到3个段落在文章中的位置已经给出。<br>3)在一篇长度约500词的文章前或后有6到7段文字或6到7个概括句或小标题。这些文字或标题分别是对文章中某一部分的概括、阐述或举例。要求考生根据文章内容,从这6到7个选项中选出最恰当的5段文字或5个标题填入文章的空白处。<br>C节(5小题):主要考查考生准确理解概念或结构较复杂的英语文字材料的能力。要求考生阅读一篇约400词的文章,并将其中5个画线部分(约150词)译成汉语,要求译文准确、完整、通顺。考生在答题卡2上作答。</p><h4 id="第三部分-写作"><a href="#第三部分-写作" class="headerlink" title="第三部分 写作"></a>第三部分 写作</h4><p>该部分由A、B两节组成,主要考查考生的书面表达能力。共30分。<br>A节:<br>考生根据所给情景写出约100词(标点符号不计算在内)的应用性短文,包括私人和公务信函、备忘录、报告等。<br>考生在答题卡2上作答。共10分。<br>B节:考生根据提示信息写出一篇160~200词的短文(标点符号不计算在内)。提示信息的形式有主题句、写作提纲、规定情景、图、表等。考生在答题卡2上作答。共20分。<br>*硕士研究生入学考试将英译汉试题作为阅读理解的一部分,其目的是测试考生根据上下文准确理解概念或复杂结构并用汉语正确予以表达的能力。</p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数一—考研大纲</title>
      <link href="2021/01/08/%E6%95%B0%E4%B8%80%E2%80%94%E8%80%83%E7%A0%94%E5%A4%A7%E7%BA%B2/"/>
      <url>2021/01/08/%E6%95%B0%E4%B8%80%E2%80%94%E8%80%83%E7%A0%94%E5%A4%A7%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="数一—考研大纲"><a href="#数一—考研大纲" class="headerlink" title="数一—考研大纲"></a>数一—考研大纲</h1><a id="more"></a><h4 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h4><p><strong>函数极限连续</strong><br>1.理解函数的概念,掌握函数的表示法,会建立应用问题的函数关系.<br>2.了解函数的有界性、单调性、周期性和奇偶性.<br>3.理解复合函数及分段函数的概念,了解反函数及隐函数的概念.<br>4.掌握基本初等函数的性质及其图形,了解初等函数的概念.<br>5.理解极限的概念,理解函数左极限与右极限的概念以及函数极限存在与左极限、右极限之间的关系.<br>6.掌握极限的性质及四则运算法则.<br>7.掌握极限存在的两个准则,并会利用它们求极限,掌握利用两个重要极限求极限的方法.<br>8.理解无穷小量、无穷大量的概念,掌握无穷小量的比较方法,会用等价无穷小量求极限.<br>9.理解函数连续性的概念(含左连续与右连续),会判别函数间断点的类型.<br>10.了解连续函数的性质和初等函数的连续性,理解闭区间上连续函数的性质(有界性、最大值和最小值定理、介值定理),并会应用这些性质.<br><strong>一元函数微分学</strong><br>考试要求<br>1.理解导数和微分的概念,理解导数与微分的关系,理解导数的几何意义,会求平面曲线的切线方程和法线方程,了解导数的物理意义,会用导数描述一些物理量,理解函数的可导性与连续性之间的关系.<br>2.掌握导数的四则运算法则和复合函数的求导法则,掌握基本初等函数的导数公式.了解微分的四则运算法则和一阶微分形式的不变性,会求函数的微分.<br>3.了解高阶导数的概念,会求简单函数的高阶导数.<br>4.会求分段函数的导数,会求隐函数和由参数方程所确定的函数以及反函数的导数.<br>5.理解并会用罗尔(Rolle)定理、拉格朗日(Lagrange)中值定理和泰勒(Taylor)定理,了解并会用柯西(Cauchy)中值定理.<br>6.掌握用洛必达法则求未定式极限的方法.<br>7.理解函数的极值概念,掌握用导数判断函数的单调性和求函数极值的方法,掌握函数最大值和最小值的求法及其应用.<br>8.会用导数判断函数图形的凹凸性(注:在区间 内,设函数 具有二阶导数。当f’’(x)&gt;0 时,f(x) 的图形是凹的;当f”(x) &lt;0时,f(x) 的图形是凸的),会求函数图形的拐点以及水平、铅直和斜渐近线,会描绘函数的图形.<br>9.了解曲率、曲率圆与曲率半径的概念,会计算曲率和曲率半径.<br><strong>一元函数积分学</strong><br>考试要求<br>1.理解原函数的概念,理解不定积分和定积分的概念.<br>2.掌握不定积分的基本公式,掌握不定积分和定积分的性质及定积分中值定理,掌握换元积分法与分部积分法.<br>3.会求有理函数、三角函数有理式和简单无理函数的积分.<br>4.理解积分上限的函数,会求它的导数,掌握牛顿-莱布尼茨公式.<br>5.理解反常积分的概念,了解反常积分收敛的比较判别法,会计算反常积分.<br>6.掌握用定积分表达和计算一些几何量与物理量(平面图形的面积、平面曲线的弧长、旋转体的体积及侧面积、平行截面面积为已知的立体体积、功、引力、压力、质心、形心等)及函数的平均值.<br><strong>向量代数和空间解析几何</strong><br>考试要求<br>1.理解空间直角坐标系,理解向量的概念及其表示.<br>2.掌握向量的运算(线性运算、数量积、向量积、混合积),了解两个向量垂直、平行的条件.<br>3.理解单位向量、方向数与方向余弦、向量的坐标表达式,掌握用坐标表达式进行向量运算的方法.<br>4.掌握平面方程和直线方程及其求法.<br>5.会求平面与平面、平面与直线、直线与直线之间的夹角,并会利用平面、直线的相互关系(平行、垂直、相交等)解决有关问题.<br>6.会求点到直线以及点到平面的距离.<br>7.了解曲面方程和空间曲线方程的概念.<br>8.了解常用二次曲面的方程及其图形,会求简单的柱面和旋转曲面的方程.<br>9.了解空间曲线的参数方程和一般方程.了解空间曲线在坐标平面上的投影,并会求该投影曲线的方程.<br><strong>多元函数微分学</strong><br>考试要求<br>1.理解多元函数的概念,理解二元函数的几何意义.<br>2.了解二元函数的极限与连续的概念以及有界闭区域上连续函数的性质.<br>3.理解多元函数偏导数和全微分的概念,会求全微分,了解全微分存在的必要条件和充分条件,了解全微分形式的不变性.<br>4.理解方向导数与梯度的概念,并掌握其计算方法.<br>5.掌握多元复合函数一阶、二阶偏导数的求法.<br>6.了解隐函数存在定理,会求多元隐函数的偏导数.<br>7.了解空间曲线的切线和法平面及曲面的切平面和法线的概念,会求它们的方程.<br>8.了解二元函数的二阶泰勒公式.<br>9.理解多元函数极值和条件极值的概念,掌握多元函数极值存在的必要条件,了解二元函数极值存在的充分条件,会求二元函数的极值,会用拉格朗日乘数法求条件极值,会求简单多元函数的最大值和最小值,并会解决一些简单的应用问题.<br><strong>多元函数积分学</strong><br>考试要求<br>1.理解二重积分、三重积分的概念,了解重积分的性质,了解二重积分的中值定理.<br>2.掌握二重积分的计算方法(直角坐标、极坐标),会计算三重积分(直角坐标、柱面坐标、球面坐标).<br>3.理解两类曲线积分的概念,了解两类曲线积分的性质及两类曲线积分的关系.<br>4.掌握计算两类曲线积分的方法.<br>5.掌握格林公式并会运用平面曲线积分与路径无关的条件,会求二元函数全微分的原函数.<br>6.了解两类曲面积分的概念、性质及两类曲面积分的关系,掌握计算两类曲面积分的方法,掌握用高斯公式计算曲面积分的方法,并会用斯托克斯公式计算曲线积分。<br>7.了解散度与旋度的概念,并会计算.<br>8.会用重积分、曲线积分及曲面积分求一些几何量与物理量(平面图形的面积、体积、曲面面积、弧长、质量、质心、形心、转动惯量、引力、功及流量等).<br><strong>无穷级数</strong><br>考试要求<br>1.理解常数项级数收敛、发散以及收敛级数的和的概念,掌握级数的基本性质及收敛的必要条件.<br>2.掌握几何级数与 级数的收敛与发散的条件.<br>3.掌握正项级数收敛性的比较判别法和比值判别法,根值判别法,会用积分判别法.<br>4.掌握交错级数的莱布尼茨判别法.<br>5. 了解任意项级数绝对收敛与条件收敛的概念以及绝对收敛与收敛的关系.<br>6.了解函数项级数的收敛域及和函数的概念.<br>7.理解幂级数收敛半径的概念、并掌握幂级数的收敛半径、收敛区间及收敛域的求法.<br>8.了解幂级数在其收敛区间内的基本性质(和函数的连续性、逐项求导和逐项积分),会求一些幂级数在收敛区间内的和函数,并会由此求出某些数项级数的和.<br>9.了解函数展开为泰勒级数的充分必要条件.<br>10.掌握泰勒级数的麦克劳林(Maclaurin)展开式,会用它们将一些简单函数间接展开成幂级数.<br>11.了解傅里叶级数的概念和狄利克雷收敛定理,会将定义在 上的函数展开为傅里叶级数,会将定义在 上的函数展开为正弦级数与余弦级数,会写出傅里叶级数的和函数的表达式.<br><strong>常微分方程</strong><br>考试要求<br>1.了解微分方程及其阶、解、通解、初始条件和特解等概念.<br>2.掌握变量可分离的微分方程及一阶线性微分方程的解法.<br>3.会解齐次微分方程、伯努利方程和全微分方程,会用简单的变量代换解某些微分方程.<br>4.会用降阶法解下列形式的微分方程: .<br>5.理解线性微分方程解的性质及解的结构.<br>6.掌握二阶常系数齐次线性微分方程的解法,并会解某些高于二阶的常系数齐次线性微分方程.<br>7.会解自由项为多项式、指数函数、正弦函数、余弦函数以及它们的和与积的二阶常系数非齐次线性微分方程.<br>8.会解欧拉方程.<br>9.会用微分方程解决一些简单的应用问题.</p><h4 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h4><p><strong>第一章:行列式</strong><br>考试内容:<br>行列式的概念和基本性质 行列式按行(列)展开定理<br>考试要求:<br>1.了解行列式的概念,掌握行列式的性质.<br>2.会应用行列式的性质和行列式按行(列)展开定理计算行列式.<br><strong>第二章:矩阵</strong><br>考试内容:<br>矩阵的概念 矩阵的线性运算 矩阵的乘法 方阵的幂 方阵乘积的行列式 矩阵的转置 逆矩阵的概念和性质矩阵可逆的充分必要条件 伴随矩阵 矩阵的初等变换初等矩阵矩阵的秩矩阵等价 分块矩阵及其运算<br>考试要求:<br>1.理解矩阵的概念,了解单位矩阵、数量矩阵、对角矩阵、三角矩阵、对称矩阵和反对称矩阵以及它们的性质.<br>2.掌握矩阵的线性运算、乘法、转置以及它们的运算规律,了解方阵的幂与方阵乘积的行列式的性质.<br>3.理解逆矩阵的概念,掌握逆矩阵的性质以及矩阵可逆的充分必要条件,理解伴随矩阵的概念,会用伴随矩阵求逆矩阵.<br>4.理解矩阵的初等变换的概念,了解初等矩阵的性质和矩阵等价的概念,理解矩阵的秩的概念,掌握用初等变换求矩阵的秩和逆矩阵的方法.<br>5.了解分块矩阵及其运算.<br><strong>第三章:向量</strong><br>考试内容:<br>向量的概念 向量的线性组合和线性表示 向量组的线性相关与线性无关 向量组的极大线性无关组等价向量组 向量组的秩 向量组的秩与矩阵的秩之间的关系 向量空间以及相关概念 n维向量空间的基变换和坐标变换 过渡矩阵 向量的内积 线性无关向量组的正交规范化方法 规范正交基 正交矩阵及其性质<br>考试要求:<br>1.理解n维向量、向量的线性组合与线性表示的概念.<br>2.理解向量组线性相关、线性无关的概念,掌握向量组线性相关、线性无关的有关性质及判别法.<br>3.理解向量组的极大线性无关组和向量组的秩的概念,会求向量组的极大线性无关组及秩.<br>4.理解向量组等价的概念,理解矩阵的秩与其行(列)向量组的秩之间的关系<br>5.了解n维向量空间、子空间、基底、维数、坐标等概念.<br>6.了解基变换和坐标变换公式,会求过渡矩阵.<br>7.了解内积的概念,掌握线性无关向量组正交规范化的施密特(Schmidt)方法.<br>8.了解规范正交基、正交矩阵的概念以及它们的性质.<br><strong>第四章:线性方程组</strong><br>考试内容:<br>线性方程组的克莱姆(Cramer)法则齐次线性方程组有非零解的充分必要条件非齐次线性方程组有解的充分必要条件 线性方程组解的性质和解的结构 齐次线性方程组的基础解系和通解 解空间 非齐次线性方程组的通解<br>考试要求<br>l.会用克莱姆法则.<br>2.理解齐次线性方程组有非零解的充分必要条件及非齐次线性方程组有解的充分必要条件.<br>3.理解齐次线性方程组的基础解系、通解及解空间的概念,掌握齐次线性方程组的基础解系和通解的求法.<br>4.理解非齐次线性方程组解的结构及通解的概念.<br>5.掌握用初等行变换求解线性方程组的方法.<br><strong>第五章:矩阵的特征值及特征向量</strong><br>考试内容:<br>矩阵的特征值和特征向量的概念、性质 相似变换、相似矩阵的概念及性质 矩阵可相似对角化的充分必要条件及相似对角矩阵 实对称矩阵的特征值、特征向量及相似对角矩阵<br>考试要求:<br>1.理解矩阵的特征值和特征向量的概念及性质,会求矩阵的特征值和特征向量.<br>2.理解相似矩阵的概念、性质及矩阵可相似对角化的充分必要条件,掌握将矩阵化为相似对角矩阵的方法.<br>3.掌握实对称矩阵的特征值和特征向量的性质.<br><strong>第六章:二次型</strong><br>考试内容:<br>二次型及其矩阵表示 合同变换与合同矩阵二次型的秩 惯性定理 二次型的标准形和规范形 用正交变换和配方法化二次型为标准形 二次型及其矩阵的正定性<br>考试要求:<br>1.掌握二次型及其矩阵表示,了解二次型秩的概念,了解合同变化和合同矩阵的概念 了解二次型的标准形、规范形的概念以及惯性定理.<br>2.掌握用正交变换化二次型为标准形的方法,会用配方法化二次型为标准形.<br>3.理解正定二次型、正定矩阵的概念,并掌握其判别法</p><h4 id="概率与统计"><a href="#概率与统计" class="headerlink" title="概率与统计"></a>概率与统计</h4><p><strong>第一章:随机事件和概率</strong><br>考试内容:<br>随机事件与样本空间 事件的关系与运算 完备事件组 概率的概念 概率的基本性质 古典型概率 几何型概率 条件概率 概率的基本公式 事件的独立性 独立重复试验 考试要求:<br>1.了解样本空间(基本事件空间)的概念,理解随机事件的概念,掌握事件的关系与运算.<br>2.理解概率、条件概率的概念,掌握概率的基本性质,会计算古典型概率和几何型概率,掌握概率的加法公式、减法公式、乘法公式、全概率公式,以及贝叶斯(Bayes)公式.<br>3.理解事件的独立性的概念,掌握用事件独立性进行概率计算;理解独立重复试验的概念,掌握计算有关事件概率的方法.<br><strong>第二章:随机变量及其分布</strong><br>考试内容:<br>随机变量 随机变量的分布函数的概念及其性质离散型随机变量的概率分布连续型随机变量的概率密度 常见随机变量的分布 随机变量函数的分布<br>考试要求:<br>1.理解随机变量的概念.理解分布函数<br>的概念及性质.会计算与随机变量相联系的事件的概率.<br>2.理解离散型随机变量及其概率分布的概念,掌握0-1分布、二项分布 、几何分布、超几何分布、泊松(Poisson)分布 及其应用.<br>3.了解泊松定理的结论和应用条件,会用泊松分布近似表示二项分布.<br>4.理解连续型随机变量及其概率密度的概念,掌握均匀分布 、正态分布 、指数分布<br>及其应用,其中参数为λ(λ&gt;0)的指数分布的概率密度为<br>5.会求随机变量函数的分布.<br><strong>第三章:多维随机变量及其分布</strong><br>考试内容<br>多维随机变量及其分布 二维离散型随机变量的概率分布、边缘分布和条件分布 二维连续型随机变量的概率密度、边缘概率密度和条件密度<br>随机变量的独立性和不相关性 常用二维随机变量的分布 两个及两个以上随机变量简单函数的分布<br>考试要求<br>1.理解多维随机变量的概念,理解多维随机变量的分布的概念和性质. 理解二维离散型随机变量的概率分布、边缘分布和条件分布,理解二维连续型随机变量的概率密度、边缘密度和条件密度,会求与二维随机变量相关事件的概率.<br>2.理解随机变量的独立性及不相关性的概念,掌握随机变量相互独立的条件.<br>3.掌握二维均匀分布,了解二维正态分布<br>的概率密度,理解其中参数的概率意义.<br>4.会求两个随机变量简单函数的分布,会求多个相互独立随机变量简单函数的分布.<br><strong>第四章:随机变量的数字特征</strong><br>考试内容<br>随机变量的数学期望(均值)、方差、标准差及其性质 随机变量函数的数学期望 矩、协方差、相关系数及其性质<br>考试要求<br>1.理解随机变量数字特征(数学期望、方差、标准差、矩、协方差、相关系数)的概念,会运用数字特征的基本性质,并掌握常用分布的数字特征<br>2.会求随机变量函数的数学期望.<br><strong>第五章:大数定律和中心极限定理</strong><br>考试内容<br>切比雪夫(Chebyshev)不等式切比雪夫大数定律伯努利(Bernoulli)大数定律辛钦(Khinchine)大数定律 棣莫弗-拉普拉斯(De Moivre-laplace)定理 列维-林德伯格(Levy-Lindberg)定理<br>考试要求<br>1.了解切比雪夫不等式.<br>2.了解切比雪夫大数定律、伯努利大数定律和辛钦大数定律(独立同分布随机变量序列的大数定律) .<br>3.了解棣莫弗-拉普拉斯定理(二项分布以正态分布为极限分布)和列维-林德伯格定理(独立同分布随机变量序列的中心极限定理) .<br><strong>第六章:数理统计的基本概念</strong><br>考试内容<br>总体 个体 简单随机样本 统计量 样本均值 样本方差和样本矩 分布 分布 分布 分位数 正态总体的常用抽样分布<br>考试要求<br>1.理解总体、简单随机样本、统计量、样本均值、样本方差及样本矩的概念,其中样本方差定义为:<br>2.了解 分布、 分布和 分布的概念及性质,了解上侧 分位数的概念并会查表计算.<br>3.了解正态总体的常用抽样分布.<br><strong>第七章:参数估计</strong><br>考试内容<br>点估计的概念 估计量与估计值 矩估计法 最大似然估计法 估计量的评选标准 区间估计的概念单个正态总体的均值和方差的区间估计两个正态总体的均值差和方差比的区间估计<br>考试要求<br>1.理解参数的点估计、估计量与估计值的概念.<br>2.掌握矩估计法(一阶矩、二阶矩)和最大似然估计法.<br>3.了解估计量的无偏性、有效性(最小方差性)和一致性(相合性)的概念,并会验证估计量的无偏性.<br>4.理解区间估计的概念,会求单个正态总体的均值和方差的置信区间,会求两个正态总体的均值差和方差比的置信区间.<br><strong>第八章:假设检验</strong><br>考试内容<br>显著性检验假设检验的两类错误 单个及两个正态总体的均值和方差的假设检验<br>考试要求<br>1.理解显著性检验的基本思想,掌握假设检验的基本步骤,了解假设检验可能产生的两类错误.<br>2.掌握单个及两个正态总体的均值和方差的假设检验</p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt—(2)</title>
      <link href="2020/12/28/Qt%E2%80%94(2)/"/>
      <url>2020/12/28/Qt%E2%80%94(2)/</url>
      
        <content type="html"><![CDATA[<h1 id="2"><a href="#2" class="headerlink" title="(2)"></a>(2)</h1><a id="more"></a><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><pre><code>connect(b4,&amp;QPushButton::released,        [=]() mutable      //[]作用:把外部变量传进来                         //=:把外部所有局部变量、类中所有成员以值的方式传进来,但是值是不可被修改的                        //mutable:允许里面的值被修改                        //this:类中所有成员以值的方式传进来                        //&amp;:外部所有局部变量以值的方式传进来,不建议使用,会发生内存上的错误。                        //也可传参,注意()中有无参数是以QPushButton::released中有无参数来决定的                        //相当于你进行了QPushButton::released操作,然后执行这个程序&#123;        b4-&gt;setText(&quot;123&quot;);        qDebug() &lt;&lt;a&lt;&lt;b;        qDebug() &lt;&lt;&quot;1111111&quot;;  //自动换行&#125;        );</code></pre><h4 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">  * 对于父窗口(主窗口),坐标系统相对于屏幕</span><br><span class="line">  * 原点:相对于屏幕最上角</span><br><span class="line">  * x:往右递增</span><br><span class="line">  * y:往下递增</span><br><span class="line">  *&#x2F;</span><br><span class="line"> move(100,100);</span><br><span class="line"> &#x2F;*</span><br><span class="line">  * 对于子窗口,坐标系统相对于父窗口</span><br><span class="line">  * 原点:相对于屏幕空白区域</span><br><span class="line">  * x:往右递增</span><br><span class="line">  * y:往下递增</span><br><span class="line">  *&#x2F;</span><br><span class="line"> QPushButton *b1&#x3D;new QPushButton(this);</span><br><span class="line"> b1-&gt;move(100,100);</span><br><span class="line"> b1-&gt;setText(&quot;^_^&quot;);</span><br><span class="line"> b1-&gt;resize(100,100);</span><br><span class="line"> </span><br><span class="line"> QPushButton *b2&#x3D;new QPushButton(b1);</span><br><span class="line"> b2-&gt;move(100,100);</span><br><span class="line"> b1-&gt;setText(&quot;@_@&quot;);</span><br></pre></td></tr></table></figure><h4 id="内存回收机制"><a href="#内存回收机制" class="headerlink" title="内存回收机制"></a>内存回收机制</h4><p><strong>条件:<br>1.指定父对象后<br>2.必须是直接或间接继承自QObject</strong><br>C++中的继承可以看成一个树形的结构,当你关闭资源后,从下往上依次自动释放资源<br>子对象如果是动态分配空间的new,不需要手动释放delete,系统会自动调用析构函数,然后释放内存。</p><h4 id="菜单栏-工具栏-状态栏-核心控件-浮动窗口的制作"><a href="#菜单栏-工具栏-状态栏-核心控件-浮动窗口的制作" class="headerlink" title="菜单栏,工具栏,状态栏,核心控件,浮动窗口的制作"></a>菜单栏,工具栏,状态栏,核心控件,浮动窗口的制作</h4><p>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &lt;QMenuBar&gt;</span><br><span class="line">#include &lt;QMenu&gt;</span><br><span class="line">#include &lt;QAction&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;QToolBar&gt;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line">#include &lt;QStatusBar&gt;</span><br><span class="line">#include &lt;QLabel&gt;</span><br><span class="line">#include &lt;QTextEdit&gt; &#x2F;&#x2F;文本编辑区</span><br><span class="line">#include &lt;QDockWidget&gt; &#x2F;&#x2F;浮动窗口</span><br><span class="line">    &#x2F;&#x2F;菜单栏</span><br><span class="line">    QMenuBar *mBar&#x3D;menuBar();</span><br><span class="line">    &#x2F;&#x2F;添加菜单</span><br><span class="line">    QMenu *pFile&#x3D;mBar-&gt;addMenu(&quot;文件&quot;);</span><br></pre></td></tr></table></figure><pre><code>//添加菜单项,添加动作QAction *pNew=pFile-&gt;addAction(&quot;新建&quot;);connect(pNew,&amp;QAction::triggered,        [=]()&#123;     qDebug()&lt;&lt;&quot;新建被摁下&quot;;&#125;        );pFile-&gt;addSeparator(); //添加分割线QAction *pOpen=pFile-&gt;addAction(&quot;打开&quot;);//工具栏,菜单项的快捷方式QToolBar *toolBar=addToolBar(&quot;toolBar&quot;);//工具栏添加快捷键toolBar-&gt;addAction(pNew);QPushButton *b=new QPushButton(this);b-&gt;setText(&quot;^_^&quot;);//添加小部件toolBar-&gt;addWidget(b);//状态栏QStatusBar *sBar = statusBar();//方法2,添加label方法QLabel *label=new QLabel(this);label-&gt;setText(&quot;Normal text file&quot;);sBar-&gt;addWidget(label);//方法1,addWidget,从左往右添加//addPermanentWidget,从右往左添加sBar-&gt;addWidget(new QLabel(&quot;2&quot;,this));//核心控件QTextEdit *texyEdit=new QTextEdit(this);setCentralWidget(texyEdit);  //默认有复制粘贴功能//浮动窗口QDockWidget *dock = new QDockWidget(this);addDockWidget(Qt::TopDockWidgetArea,dock);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt—相关语法</title>
      <link href="2020/12/26/Qt%E2%80%94%E7%9B%B8%E5%85%B3%E8%AF%AD%E6%B3%95/"/>
      <url>2020/12/26/Qt%E2%80%94%E7%9B%B8%E5%85%B3%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="相关语法"><a href="#相关语法" class="headerlink" title="相关语法"></a>相关语法</h1><a id="more"></a><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>条件:&ensp;<br>用途:&ensp;<br>例子:&ensp;<br><strong>注意</strong>:&ensp; </p><h4 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h4><p>条件:&ensp; <code>QPushButton a;</code><br>用途:&ensp; 获取a的size,可由一个QSize对象获取<br>例子:&ensp; <code>QSize b=a.size();</code><br><strong>注意</strong>:&ensp; b应该是一个二维值,因为size有宽和长</p><h4 id="resize-const-const"><a href="#resize-const-const" class="headerlink" title="resize(const,const)"></a>resize(const,const)</h4><p>条件:&ensp; <code>QPushButton a;</code><br>用途:&ensp; 修改按钮a的size<br>例子:&ensp; <code>a.resize(40,40);</code><br><strong>注意</strong>:</p><h4 id="qDebug的使用"><a href="#qDebug的使用" class="headerlink" title="qDebug的使用"></a>qDebug的使用</h4><p>条件:&ensp; <code>#include &lt;QDebug&gt;</code><br>用途:&ensp; 与C++语法cout一样,用作打印<br>例子:&ensp; <code>qDebug() &lt;&lt;a &lt;&lt;str ;</code><br><strong>注意</strong>:&ensp; 这里是qDebug()而不是QDebug。</p><h4 id="addDockWidget-Qt-DockWidgetArea-dock"><a href="#addDockWidget-Qt-DockWidgetArea-dock" class="headerlink" title="addDockWidget(Qt::DockWidgetArea,dock)"></a>addDockWidget(Qt::DockWidgetArea,dock)</h4><p>条件:&ensp; <code>#include &lt;QDockWidget&gt;</code><br>用途:&ensp; 添加一个浮动窗口,前面参数是写放置的位置,后面是窗口指针<br>例子:&ensp; <code>addDockWidget(Qt::TopDockWidgetArea,dock);</code><br><strong>注意</strong>:&ensp; </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Qt::LeftDockWidgetArea</span><br><span class="line">Qt::RightDockWidgetArea</span><br><span class="line">Qt::TopDockWidgetArea</span><br><span class="line">Qt::BottomDockWidgetArea</span><br><span class="line">Qt::AllDockWidgetAreas</span><br><span class="line">Qt::NoDockWidgetArea</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt—信号与槽</title>
      <link href="2020/12/26/Qt%E2%80%94%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/"/>
      <url>2020/12/26/Qt%E2%80%94%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a>信号与槽</h1><a id="more"></a><h4 id="connent函数"><a href="#connent函数" class="headerlink" title="connent函数"></a>connent函数</h4><p> <strong>connect函数参数:</strong><br> <strong>1. 信号发出者,指针类型。</strong><br> <strong>2. 处理的信号,&amp;取地址,发送者的类名::信号名。</strong><br> <strong>3. 信号接收者。</strong><br> <strong>4. 槽函数:信号处理函数,函数接收者的类名::信号名。</strong></p><p>例如:</p><pre><code>connect(&amp;a,&amp;QPushButton::pressed,this,&amp;MainWidget::close);/* * &amp;a 信号发出者,指针类型 * &amp;QPushButton::pressed 处理的信号,&amp;取地址,发送者的类名::信号名 * this 信号接收者 * &amp;MainWidget::close 槽函数:信号处理函数,函数接收者的类名::信号名 */</code></pre><p>解释:a是一个按钮,当你pressed这个按钮后,a发出一个信号,给this对象(也就是父对象),然后this接受后,作出close的行为。</p><p>这里的close和pressed皆为标准函数,如何自己自定义一个槽函数呢?<br>首先,我需要在头文件里声明一个函数:</p><pre><code>public:void mySlot();</code></pre><p>然后,我需要在cpp里实现这个函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void MainWidget::mySlot()</span><br><span class="line">&#123;</span><br><span class="line">    b-&gt;setText(&quot;123&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后,在connnect里引用:</p><pre><code>connect(b,&amp;QPushButton::released,this,&amp;MainWidget::mySlot);</code></pre><p><strong>注意:<br>      1. 槽函数需要和信号一致(参数,返回值)<br>      2. 由于信号都是没有返回值的,所以槽函数一定没有返回值</strong></p><p><strong>什么时候需要自定义信号?</strong><br>比如,你老板可以命令你做什么事,但是你不能直接命令老板做事,你需要先私下里发个信息给老板,等待老板确定并执行。这里的这个信息,就是你要自定义的信号。</p><h4 id="如何自定义信号-无参数"><a href="#如何自定义信号-无参数" class="headerlink" title="如何自定义信号(无参数)?"></a>如何自定义信号(无参数)?</h4><p>1.你要在子对象的.h文件里里创建signal声明:</p><pre><code>signals:void mySignal();</code></pre><p>2.接着在.h文件里创建一个送出这个信号的函数:</p><pre><code>public:void sendSlot();</code></pre><p>3.然后在.cpp文件里实现这个函数:</p><pre><code>void SubWidget::sendSlot()&#123;    emit mySignal();&#125;</code></pre><p>4.在.cpp里运用connect函数将这个信号发给父对象:</p><pre><code>  connect(&amp;a,&amp;QPushButton::clicked,this,&amp;SubWidget::sendSlot);</code></pre><p>5.在父对象的.h文件里,创建一个接收到了这个信号后的处理函数:</p><pre><code>public:void dealSub();</code></pre><p>6.在父对象的.cpp文件里,实现这个函数,就是写你要的操作:</p><pre><code>void MainWidget::dealSub()&#123;    this-&gt;show();    w.hide();&#125;</code></pre><p>7.在父对象运用connect函数,接收信号:<br><strong>注意!!!这里的&amp;SubWidget::mySignal,发送的是信号名!!!而不是sendSlot函数,作为接收者,接收的是这个信号</strong></p><pre><code>connect(&amp;w,&amp;SubWidget::mySignal,this ,&amp;MainWidget::dealSub);</code></pre><h4 id="如何自定义信号-有参数"><a href="#如何自定义信号-有参数" class="headerlink" title="如何自定义信号(有参数)?"></a>如何自定义信号(有参数)?</h4><p>大致步骤与无参定义信号差不多,不同处已<strong>加粗标记</strong><br>1.你要在子对象的.h文件里里创建signal声明:</p><pre><code>signals:void mySignal(int,QString);</code></pre><p>2.接着在.h文件里创建一个送出这个信号的函数:</p><pre><code>public:void sendSlot();</code></pre><p>3.然后在.cpp文件里实现这个函数<strong>并填写上你要添加的参数</strong>:</p><pre><code>void SubWidget::sendSlot()&#123;  emit mySignal(250,&quot;我是子窗口&quot;);&#125;</code></pre><p>4.在.cpp里运用connect函数将这个信号发给父对象:</p><pre><code>  connect(&amp;a,&amp;QPushButton::clicked,this,&amp;SubWidget::sendSlot);</code></pre><p>5.在父对象的.h文件里,创建一个接收到了这个信号后的处理函数,<strong>因为信号是有参数的所以你的槽函数也要有参数</strong>:</p><pre><code>public:void dealSub(int,QString);</code></pre><p>6.在父对象的.cpp文件里,实现这个函数,就是写你要的操作:</p><pre><code>void MainWidget::dealSub(int,QString)&#123;    this-&gt;show();    w.hide();    qDebug() &lt;&lt;a &lt;&lt;str ;//打印a和str的值,详细信息请去Qt相关语法&#125;</code></pre><p>7.在父对象运用connect函数,接收信号:<br><strong>注意!!!这里的&amp;SubWidget::mySignal,发送的是信号名!!!而不是sendSlot函数,作为接收者,接收的是这个信号</strong></p><pre><code>connect(&amp;w,&amp;SubWidget::mySignal,this ,&amp;MainWidget::dealSub);</code></pre><h4 id="信号的重载问题"><a href="#信号的重载问题" class="headerlink" title="信号的重载问题"></a>信号的重载问题</h4><p>信号是可以重载的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">void mySignal();</span><br><span class="line">void mySignal(int,QString);</span><br></pre></td></tr></table></figure><p>此时当你在父对象里创建connect函数与子对象发来的函数相连时:</p><pre><code>  connect(&amp;w,&amp;SubWidget::mySignal,this ,&amp;MainWidget::dealSub);</code></pre><p>会发生报错,错误原因:<strong>子对象发送的这个mySignal,父对象不知道你发的是无参的还是有参的。</strong><br>所以你需要用<strong>指针来分别指向有参和无参信号函数</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connect(&amp;c,&amp;QPushButton::pressed,this,&amp;MainWidget::showchild);</span><br><span class="line">void (SubWidget::*funSignal)()&#x3D;&amp;SubWidget::mySignal;  &#x2F;&#x2F;这个指针要加上作用域SubWidget::,因为你这个信号是属于SubWidget::子类的</span><br><span class="line">                                                      &#x2F;&#x2F;C++用指针来指定函数★</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt—小知识</title>
      <link href="2020/12/26/Qt%E2%80%94%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
      <url>2020/12/26/Qt%E2%80%94%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h1><a id="more"></a><h4 id="程序的构建可能会失败问题"><a href="#程序的构建可能会失败问题" class="headerlink" title="程序的构建可能会失败问题"></a>程序的构建可能会失败问题</h4><p><img src="D:\Blog\source\images\1.jpg"><br>每次构建一次项目时,它都会生成一个这样的文件,这个文件的意思是,你本机电脑的构建目录,它与QT里的构建目录挂钩:<br><img src="D:\Blog\source\images\2.jpg"><br>所以当你使用别的程序时,要把这个文件给删掉再构建不然会出错,因为你和他在构建这个程序时目录是不一样的</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt—(1)</title>
      <link href="2020/12/24/Qt%E2%80%94(1)/"/>
      <url>2020/12/24/Qt%E2%80%94(1)/</url>
      
        <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="(1)"></a>(1)</h1><hr><a id="more"></a><blockquote><p>今天的QT学习:<br>(1)Qt应用程序框架<br>(2)父对象的指定&lt;就是将按钮绑定到窗口上&gt;<br>(3)实现两个独立的窗口<br>(4)<strong>信号与槽</strong></p></blockquote><p><strong>Qt应用程序框架:</strong><br>main.cpp</p><pre><code>#include &quot;mywidget.h&quot;#include &lt;QApplication&gt;  //QApplication应用程序类                         //QT头文件没有.h                        //头文件和类名一样                        //前两个字母是大写int main(int argc, char *argv[])&#123;    //有且只有一个应用程序类的对象    QApplication a(argc, argv);    //MyWidget继承于QWidget, QWidget是一个窗口基类    //所以MyWidget也是窗口类    //w就是一个窗口    MyWidget w;    //窗口创建默认是隐藏的,需要show    w.show();    //a.exec();  让程序一直执行,等待用户操作 or 等待事件的发生    //return 0;    return a.exec();&#125;</code></pre><p>mywidget.h</p><pre><code>#ifndef MYWIDGET_H#define MYWIDGET_H#include &lt;QWidget&gt;class MyWidget : public QWidget&#123;    Q_OBJECT   //信号与槽的时候需要public:    MyWidget(QWidget *parent = nullptr);    ~MyWidget();//析构函数,用来扫尾的,就是释放内存等功能&#125;;#endif // MYWIDGET_H</code></pre><p>mywidget.cpp</p><pre><code>#include &quot;mywidget.h&quot;MyWidget::MyWidget(QWidget *parent)    : QWidget(parent)&#123;&#125;MyWidget::~MyWidget()&#123;&#125;</code></pre><p>就是mywidget对象</p><p><strong>父对象的指定&lt;就是将按钮绑定到窗口上&gt;</strong><br>父对象指定有两种方法:</p><ol><li><p>setParent</p><p>QPushButton b;<br>b.setText(“^_^”);  //给标题设置内容<br>b.setParent(&amp;w);<br>b.move(100,100);  //以像素点为单位</p></li><li><p>通过构造函数传参</p><p> QPushButton c(&amp;w);  //通过构造函数传参<br> c.setText(“abc”);</p></li></ol><p>指定父对象,只需要父对象显示,上面的子对象自动显示,这样就不需要一直用show</p><p><strong>实现两个独立的窗口</strong></p><ol><li>右击你的项目add new file</li><li>添加C++ class</li><li>命名,选择基类(父类)为QWidget,下一步</li><li>修改你要放入的文件</li></ol><p><strong>信号与槽</strong><br>关于信号与槽,移步至《Qt—信号与槽》</p><p><strong>项目03_SigalAndSlot实现的是两个窗口,一个父窗口一个子窗口,一开始子窗口是隐藏的,你按父窗口上的按键可以隐藏父窗口显示子窗口,然后你按子窗口上的按键可以隐藏子窗口,显示父窗口</strong></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构—双向链表</title>
      <link href="2020/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>2020/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><a id="more"></a><p><strong>结构体</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct link</span><br><span class="line">&#123;</span><br><span class="line">     int data;</span><br><span class="line">     struct link *left;</span><br><span class="line">     struct link *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>双向链表的创建</strong>：<br>创建添加一个节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct link *addnode(struct link *head)</span><br><span class="line">&#123;</span><br><span class="line">     struct link *p&#x3D;NULL,*pr&#x3D;head;</span><br><span class="line">     int data;</span><br><span class="line">     p&#x3D;new link();</span><br><span class="line">     if(p&#x3D;&#x3D;NULL)</span><br><span class="line">     &#123;</span><br><span class="line">         cout&lt;&lt;&quot;内存分配失败&quot;&lt;&lt;endl;</span><br><span class="line">         exit(0);</span><br><span class="line">     &#125;</span><br><span class="line">     if(head&#x3D;&#x3D;NULL)</span><br><span class="line">     &#123;</span><br><span class="line">         head&#x3D;p;</span><br><span class="line">         p-&gt;left&#x3D;NULL;</span><br><span class="line">     &#125;</span><br><span class="line">     else</span><br><span class="line">     &#123;</span><br><span class="line">         while(pr-&gt;right!&#x3D;NULL)</span><br><span class="line">         &#123;</span><br><span class="line">             pr&#x3D;pr-&gt;right;</span><br><span class="line">         &#125;</span><br><span class="line">         pr-&gt;right&#x3D;p;</span><br><span class="line">         p-&gt;left&#x3D;pr;          &#x2F;&#x2F;关键</span><br><span class="line">     &#125;</span><br><span class="line">     cout&lt;&lt;&quot;请输入节点数据&quot;&lt;&lt;endl;</span><br><span class="line">     cin&gt;&gt;data;</span><br><span class="line">     p-&gt;data&#x3D;data; </span><br><span class="line">     p-&gt;right&#x3D;NULL;</span><br><span class="line">     return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双向链表的节点删除</strong><br>这里是释放一个节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void deletenode(struct link *head,int data)</span><br><span class="line">&#123;</span><br><span class="line">           struct link *p&#x3D;head;</span><br><span class="line">           struct link *p1&#x3D;NULL;</span><br><span class="line">           while(p-&gt;data!&#x3D;data)</span><br><span class="line">           &#123;</span><br><span class="line">               p1&#x3D;p;</span><br><span class="line">               p&#x3D;p-&gt;right;</span><br><span class="line">           &#125;</span><br><span class="line">           p1-&gt;right&#x3D;p-&gt;right;     &#x2F;&#x2F;关键</span><br><span class="line">           p-&gt;right-&gt;left&#x3D;p1;</span><br><span class="line">           free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>列出所有节点信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void DisplayNode(struct link *head) </span><br><span class="line">&#123;</span><br><span class="line">struct link *p&#x3D;head;</span><br><span class="line">int j&#x3D;1;</span><br><span class="line">while(p!&#x3D;NULL)</span><br><span class="line">&#123;</span><br><span class="line">    if(p-&gt;left&#x3D;&#x3D;NULL)</span><br><span class="line">    &#123;</span><br><span class="line">       cout&lt;&lt;&quot;此节点的左节点为:NULL&quot;&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;&quot;此节点的右节点为:&quot;&lt;&lt;p-&gt;right-&gt;data&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(p-&gt;right&#x3D;&#x3D;NULL)</span><br><span class="line">    &#123;</span><br><span class="line">       cout&lt;&lt;&quot;此节点的左节点为:&quot;&lt;&lt;p-&gt;left-&gt;data&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;&quot;此节点的右节点为:NULL&quot;&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">       cout&lt;&lt;&quot;此节点的左节点为:&quot;&lt;&lt;p-&gt;left-&gt;data&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;&quot;此节点的右节点为:&quot;&lt;&lt;p-&gt;right-&gt;data&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    p&#x3D;p-&gt;right;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在固定的位置插入节点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void insertnode(struct link *head,int data)</span><br><span class="line">&#123;</span><br><span class="line">           struct link *p&#x3D;head;</span><br><span class="line">           struct link *p1&#x3D;NULL;</span><br><span class="line">           struct link *p2&#x3D;NULL;</span><br><span class="line">           p2&#x3D;new link();</span><br><span class="line">           int data2;</span><br><span class="line">           while(p-&gt;data!&#x3D;data)</span><br><span class="line">           &#123;</span><br><span class="line">               p1&#x3D;p;</span><br><span class="line">               p&#x3D;p-&gt;right;</span><br><span class="line">           &#125;</span><br><span class="line">           p1&#x3D;p;</span><br><span class="line">           p&#x3D;p-&gt;right;</span><br><span class="line"></span><br><span class="line">           cout&lt;&lt;&quot;请输入你要插入的节点的数据&quot;&lt;&lt;endl;</span><br><span class="line">           cin&gt;&gt;data2;</span><br><span class="line">           p2-&gt;data&#x3D;data2;</span><br><span class="line">           p2-&gt;left&#x3D;NULL;</span><br><span class="line">           p2-&gt;right&#x3D;NULL;</span><br><span class="line"></span><br><span class="line">           p1-&gt;right&#x3D;p2;     &#x2F;&#x2F;关键</span><br><span class="line">           p2-&gt;right&#x3D;p;</span><br><span class="line">           p-&gt;left&#x3D;p2;</span><br><span class="line">           p2-&gt;left&#x3D;p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MAIN函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char juge;</span><br><span class="line">    int i&#x3D;0;</span><br><span class="line">    struct link *head&#x3D;NULL;</span><br><span class="line">    cout&lt;&lt;&quot;是否需要添加一个节点？(Y&#x2F;N)&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;juge;</span><br><span class="line">    while(juge&#x3D;&#x3D;&#39;Y&#39;)</span><br><span class="line">    &#123;</span><br><span class="line">        head&#x3D;addnode(head);</span><br><span class="line">        cout&lt;&lt;&quot;是否需要再添加一个节点？(Y&#x2F;N)&quot;&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;juge;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;请问你是否要删除节点？(Y&#x2F;N)&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;juge;</span><br><span class="line">    if(juge&#x3D;&#x3D;&#39;Y&#39;)</span><br><span class="line">    &#123;</span><br><span class="line">    cout&lt;&lt;&quot;请输入你要删除的节点数据&quot;&lt;&lt;endl;</span><br><span class="line">    int data;</span><br><span class="line">    cin&gt;&gt;data;</span><br><span class="line">    deletenode(head,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;请问你是否要插入节点？(Y&#x2F;N)&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;juge;</span><br><span class="line">    if(juge&#x3D;&#x3D;&#39;Y&#39;)</span><br><span class="line">    &#123;</span><br><span class="line">    cout&lt;&lt;&quot;请输入你要插入在哪个节点后面&quot;&lt;&lt;endl;</span><br><span class="line">    int data;</span><br><span class="line">    cin&gt;&gt;data;</span><br><span class="line">    insertnode(head,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    displaynode(head);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构—单链表</title>
      <link href="2020/11/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
      <url>2020/11/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><a id="more"></a><p><strong>结构体</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct link</span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct link *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>单链表的创建</strong>：<br>创建添加一个节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct link *AddNode(struct link *head)</span><br><span class="line">&#123;</span><br><span class="line">    struct link *p&#x3D;NULL,*pr&#x3D;head;</span><br><span class="line">int data;</span><br><span class="line">p&#x3D;new link(); </span><br><span class="line">if(p&#x3D;&#x3D;NULL)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;分配内存失败&quot;&lt;&lt;endl;</span><br><span class="line">    exit(0);&#x2F;&#x2F;非正常退出</span><br><span class="line">&#125;</span><br><span class="line">if(head&#x3D;&#x3D;NULL)</span><br><span class="line">&#123;</span><br><span class="line">    head&#x3D;p;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    while(pr-&gt;next!&#x3D;NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        pr&#x3D;pr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pr-&gt;next&#x3D;p;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;请输入节点数据&quot;&lt;&lt;endl;</span><br><span class="line">cin&gt;&gt;data;</span><br><span class="line">p-&gt;data&#x3D;data;</span><br><span class="line">p-&gt;next&#x3D;NULL;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单链表的节点删除</strong><br>这里是将所有节点都释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void DeletMemory(struct link*head)</span><br><span class="line">&#123;</span><br><span class="line">    struct link*p&#x3D;head,*pr&#x3D;NULL;</span><br><span class="line">    while(p!&#x3D;NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        pr&#x3D;p;</span><br><span class="line">        p&#x3D;p-&gt;next;</span><br><span class="line">        free(pr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>列出所有节点信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void DisplayNode(struct link *head) </span><br><span class="line">&#123;</span><br><span class="line">     struct link *p&#x3D;head;</span><br><span class="line">     int j&#x3D;1;</span><br><span class="line">     while(p!&#x3D;NULL)</span><br><span class="line">   &#123;</span><br><span class="line">    cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">    p&#x3D;p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##malloc与new<br>1.使用malloc要加上头文件#include<malloc>，并且malloc是和free一起使用的<br>2.(struct link <em>)这条语句的原因是malloc返回的是一个空的指针，你需要将他强制转换为struct link</em>类型的指针，C++规定void *类型可以强转为任何其他类型的的指针。<br>3.malloc函数的意思是分配一个内存大小至少为size参数所指定的字节数。<br>4.malloc的分配的内存大小需要我们自己计算,new可以自动计算。<br><strong>6.在C++中无疑用new来创建是更好的：P=new link();</strong><br>因为：比如你要在结构体中使用string，会出现内存错误，是因为使用malloc分配一个结构体内存，但是string是一个类。并没有调用string的构造函数，所以string在malloc之后没有正确构造，导致使用时段错误。</p><p>详情请见：</p><h3 id="malloc和new的区别"><a href="#malloc和new的区别" class="headerlink" title="malloc和new的区别"></a><a href="https://www.cnblogs.com/QG-whz/p/5140930.html">malloc和new的区别</a></h3>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Don&#39;t want to regret</title>
      <link href="2020/11/16/Te/"/>
      <url>2020/11/16/Te/</url>
      
        <content type="html"><![CDATA[<p>没有执行力，就没有竞争力</p><p>你看我越是穷途末路 越是势如破竹</p><p>城市慷慨亮整夜光，如同少年不惧岁月长</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
